#
# simta.conf template
#
core {
    # Base directory for simta queues and queue-like things.
    base_dir = /var/spool/simta;
    # File to store the main simta pid in.
    pid_file = /var/run/simta.pid;
    # Verbosity level, from 0 to 8
    debug_level = 1;
}

# MASQUERADE <hostname>
#
# Hostname to use for locally generated mail. Defaults to the system
# hostname.

# Adds a DNSxL rule to a chain. The 'connect' chain is used during
# initial connection, the 'user' chain is used for RCPT to users with
# extra DNSxLs enabled (usually via an LDAP attribute), the 'authz'
# chain is used for authorization of authenticated users, and the
# 'email' chain is used for RFC5321.MailFrom filtering.
#
# Being found on a list will terminate processing of that DNSxL chain
# unless it's a LOG_ONLY list. TRUST is the same as ACCEPT but exempts
# the connection from checks like MAX_FAILED_RCPTS.
#
#dns_list connect {
#   # <BLOCK|ACCEPT|TRUST|LOG_ONLY>
#   action = block;
#   list = mx-deny.dnsbl;
#   message = denied by local policy;
#   #algorithm = sha1;
#}

receive {
    # NORMAL        Treat all incoming connections normally
    # OFF           Disable all SMTP service
    # REFUSE        Listen on configured ports, but refuse connections with a
    #               "554 No SMTP service here" banner
    # GLOBAL_RELAY  Accept all mail regardless of security concerns
    #               Don't enable this unless you know what you're doing,
    #               because you become an open relay
    # TEMPFAIL      Tempfail all mail.
    # TARPIT        Delays SMTP replies and rejects all mail transactions
    #               after the message data is received
    mode = normal;
    # Listening ports
    port = 25;
#   port = 587;
#   tls_port = 465;
    ipv4 = on;
    ipv6 = off;

    limits {
        global {
            # Maximum number of connections
            connections = 0;
            # Maximum number of connections per throttle_interval
            throttle = 0;
        }
        per_host {
            connections = 0;
            throttle = 0;
        }
        throttle_interval = 1s;
        # Maximum number of Received: headers; this will eventually
        # terminate trivial mail loops.
        received_headers = 50;
        # Maximum message size.
        message_size = -1;
    }

    # <TEMPFAIL|TARPIT|DISCONNECT>
    # Bad client behaviour will make simta apply this punishment when certain
    # other config options are set.
    punishment = tempfail;

    # Enable PROXY protocol
    proxy {
        enabled = false;
        timeout = 10s;
    }
    rdns {
        # <STRICT|RELAXED|CHILLAXED>
        # RELAXED allows connections with invalid rDNS, CHILLAXED also allows
        # connections with DNS errors during rDNS lookup.
        check = strict;
        #message = denied by local policy;
    }
    libwrap {
        enabled = true;
        #message = denied by local policy;
    }
    banner {
        delay: 0s;
        punish_writes: false;
    }

    smtp {
        # Strict command parsing. Enabling this is probably a bad idea, because
        # people are bad at RFC compliance.
        strict = false;
        # <MSA|MTA|MTA_STRICT>
        # MSA mode will attempt to add missing headers to submitted messages.
        # MTA_STRICT will reject mail that fails RFC compliance checks.
        mode = mta;
    }
    tls {
        enabled = false;
        #certificate = /path/to/cert;
        #key = /path/to/key;
        ciphers = "EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:DH+CHACHA20:DH+AES128:DH+AES256:!MD5";
    }
    authn {
        enabled = false;
        # Advertise fake authentication support and punish people who try to
        # use it.
        honeypot = false;
        # Override the SASL library's normal determination of the hostname.
        #sasl_domain = example.com;
        # Default authorization result after successful authentication.
        authz = allow;
        # Controls whether an RFC 7001 Authentication-Results header is added
        # to the message. If ARC is enabled, an ARC header set (including
        # ARC-Authentication-Results) will be added instead.
        results_header = true;
        # ADMD domain for the header; defaults to masquerade.
        #results_domain = example.com;
    }
    # Number of failed recipients before punishment begins. 0 is unlimited.
    max_failed_rcpts = 0;
    srs {
        enabled = false;
        # <ALWAYS|FOREIGN|SMART>
        # FOREIGN rewrites addresses from other domains.
        # SMART rewrites addresses that would fail SPF on the next hop.
        rewrite = foreign;
        # Defaults to masquerade, which defaults to the hostname.
        #domain = example.com
        #secret = theverysecretdiaries;
    }
    checksum {
        enabled = false;
        # Which digest algorithms are available depends on your TLS library's
        # configuration.
        algorithm = sha1;
        # Enables calculation of a second body-only checksum.
        body = true;
    }
    spf {
        enabled = true;
        strict = false;
    }
    dkim {
        enabled = true;
    }
    dmarc {
        enabled = true;
        strict = false;
        # Location of the Public Suffix List (available from
        # https://publicsuffix.org/). Without this, DMARC checks will not
        # attempt to determine the Organizational Domain and will return
        # inaccurate results for subdomains.
        #public_suffix_file = /path/to/psl;
    }
    arc {
        enabled = true;
        # These default to the DKIM signing settings
        #domain = example.com;
        #selector = simta;
        #key = /path/to/key;
    }

# Call a content filter to examine the DATA portion of an incoming SMTP
# message.
#
# When the content filter runs, the following environment variables are set:
#
# SIMTA_DFILE                   path to message's Dfile
# SIMTA_TFILE                   path to message's tfile
# SIMTA_REMOTE_IP               IP address of remote host
# SIMTA_REMOTE_HOSTNAME         hostname of remote host
# SIMTA_REVERSE_LOOKUP          forward-confirmed reverse DNS status
#       REVERSE_MATCH               0
#       REVERSE_ERROR               1
#       REVERSE_UNKNOWN             2
#       REVERSE_MISMATCH            3
#       REVERSE_UNRESOLVED          4
# SIMTA_SMTP_MAIL_FROM          message's RFC5321.MailFrom
# SIMTA_SMTP_HELO               HELO/EHLO hostname given by remote host
# SIMTA_HEADER_FROM             message's RFC5322.From
# SIMTA_MID                     message's RFC5322.Message-ID
# SIMTA_UID                     message UID assigned by simta
# SIMTA_PID                     calling process's PID
# SIMTA_CID                     calling process's Connection ID
# SIMTA_WRITE_BEFORE_BANNER     whether the client wrote before the SMTP banner
# SIMTA_AUTH_ID                 authenticated identity, if any
# SIMTA_CHECKSUM                message checksum
# SIMTA_CHECKSUM_SIZE           number of bytes that were checksummed
# SIMTA_BODY_CHECKSUM           message body checksum
# SIMTA_BODY_CHECKSUM_SIZE      number of bytes that were checksummed
# SIMTA_BAD_HEADERS             result of cursory header validity check
# SIMTA_SPF_RESULT              result of SPF check
# SIMTA_DMARC_RESULT            result of DMARC check
#
# The first line of text returned from the content filter will be
# logged and displayed to the SMTP client.
#
# The content filter return code is a bitfield.
#
# Results:
# 0x0000 0000   MESSAGE_ACCEPT
# 0x0000 0001   MESSAGE_TEMPFAIL
# 0x0000 0010   MESSAGE_REJECT
#
# Options:
# 0x0000 0100   MESSAGE_DELETE
# 0x0000 1000   MESSAGE_DISCONNECT
# 0x0001 0000   MESSAGE_TARPIT
# 0x0010 0000   MESSAGE_JAIL
# 0x0100 0000   MESSAGE_BOUNCE
#
# If the content filter process is terminated abnormally, it will
# return MESSAGE_TEMPFAIL.

    content_filter {
        #path = /path/to/filter
        # <ALWAYS|UNTRUSTED>
        filter = always;
        #message = denied by local policy;
    }

    queue {
        # <FAST|SLOW|JAIL>
        # FAST  The Receive child will attempt delivery
        # SLOW  Messages will be sent to the slow queue without an initial
        #       delivery attempt.
        # JAIL  Incoming messages will be jailed.
        strategy = fast;
        # simta will wait to trigger a delivery attempt until it has accumulated
        # this number of messages (-1 is unlimited)...
        aggression = 50;
        # ...or this amount of time has gone by with no new mail transactions.
        timer = -1;
    }
}

expand {
    # If enabled, simta will expand all messages in the unexpanded queue before
    # making a delivery attempt.
    aggressive = true;
    # Some expansion types will canonicalize email addresses during
    # expansion by stripping the first occurrence of the separator in the
    # localpart and anything after it.  E.g. if this is set to '+' the
    # address 'junk+foo@example.com' will be treated as an alias of
    # 'junk@example.com'.
    #subaddress_separator = +;
}


deliver {
    dkim {
        enabled = false;
        # <ALWAYS|LOCAL|BOUNCES>
        sign = always;
        # Defaults to masquerade, which defaults to the hostname.
        #domain = example.com;
        selector = simta;
        #key = /path/to/key
    }
    # If set, simta will inject a SIMTA-Seen-Before trace header into
    # outgoing mail. Incoming mail with a matching SIMTA-Seen-Before
    # header will be accepted and deleted.
    #seen_before_domain = example.com;
    queue {
        # max age before messages bounce
        bounce = 3d;
        # messages larger than this will be truncated to just the headers in
        # the NDR.
        bounce_size = 524288;
    }
}

tls {
#   ca_directory = /path/to/dir;
#   ca_file = /path/to/file;
}

red_defaults {
    alias {
        path = /etc/aliases.db;
    }
    password {
        path = /etc/passwd;
    }
    ldap {
        timeout = 180;
        attributes {
            mail = mail;
            forwarding = mail;
            request = [ * ];
        }
        bind {
            method = simple;
        }
        objectclasses {
            person = [ umichperson ];
            group = [ rfc822mailgroup ];
        }
    }
    receive {
        user_not_found = User not found;
    }
    deliver {
        connection {
            # Keep reconnecting to MX entries that accepted at least one message.
            aggressive = true;
            max_messages = 0;
            # Maximum number of recipients to attempt per message transaction.
            max_rcpts = 0;
        }

        queue {
            # <FIFO|SHUFFLE>
            strategy = fifo;
            wait {
                # If a host is up, delivery attempts will occur approximately
                # this far apart.
                min = 5min;
                # If a host is down, simta will back off attempt frequency, but
                # will retry at least this often.
                max = 80min;
            }
        }
        punt {
            enabled = false;
            always = false;
            host = "";
        }
        jail {
            host = "";
        }
        local {
            enabled = false;
            agent = /usr/libexec/simta/simda $R /usr/bin/procmail -f $S;
        }
        bitbucket {
            # <NEVER|ALWAYS>
            when = never;
            delay = 0s;
        }
        secondary_mx = false;
        tls {
            enabled = true;
            required = false;
            verify = false;
            ciphers = "EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:!MD5";
        }
    }

}

#domain "example.com" {
#   rule {
#       type = alias;
#       path = /etc/mail/aliases.example.com.db;
#       receive {
#           enabled = true;
#           required = false;
#           sufficient = true;
#       }
#       expand {
#           enabled = true;
#       }
#   }
#   rule {
#       type = accept;
#   }
#   rule {
#       type = password;
#       path = /etc/passwd;
#   }
#   rule {
#       type = ldap;
#       uri = ldap://ldap.example.com/
#       debug = false;
#       tls {
#           enabled = false;
#           required = false;
#           ca = "";
#       }
#       bind {
#           dn = "cn=simta,ou=mail agents,ou=Security,dc=umich,dc=edu";
#           password = drowssap;
#           # <SIMPLE|SASL>
#           method = simple;
#       }
#       timeout = 3min;
#       # This is a fairly hacky thing that allows subdomain users to
#       # match for moderation/membersonly purposes.
#       significant_domain_components = 2;
#       # This allows you to set a different domain for group addresses like
#       # -owners and -requests
#       associated_domain = umich.edu;
#       objectclasses {
#           person = [ umichperson ];
#           group = [ rfc822mailgroup ];
#       }
#       search {
#           uri = "ldap:///ou=People,dc=umich,dc=edu?*?sub?uid=%25s";
#           rdnpref = false;
#           # <ALL|USER|GROUP>
#           type = user;
#       }
#       search {
#           uri = "ldap:///ou=People,dc=umich,dc=edu?*?sub?cn=%25s"
#           rdnpref = false;
#           type = user;
#       }
#       # List of attributes to retrieve; if not set, all attributes are requested.
#       attributes {
#           request = [];
#           mail = mail
#           forwarding = mailforwardingaddress;
#           group_forwarding = mailforwardingaddress;
#           vacation = onvacation;
#
#       vacation {
#           host = vacation.example.com;
#       }
#   }
#   rule {
#       type = srs;
#       secret = foo;
#   }
#   deliver {
#       secondary_mx = true;
#       local_delivery = false;
#       lda = /usr/bin/procmail -f $S;
#       tls {
#           enabled = true;
#           required = false;
#           verify = false;
#           #ciphers = MD5;
#       }
#       bitbucket {
#           when = never;
#           delay = 0s;
#       }
#   }
#
#}


# Timeouts
#
# These variables set specific timeouts for various parts of the mail
# transaction.
#
#RECEIVE_GLOBAL_SESSION_TIMEOUT 0
#RECEIVE_TLS_ACCEPT_TIMEOUT 300
#RECEIVE_COMMAND_INACTIVITY_TIMEOUT 3600
#RECEIVE_COMMAND_LINE_TIMEOUT 600
#RECEIVE_DATA_SESSION_TIMEOUT 3600
#RECEIVE_DATA_LINE_TIMEOUT 300
#
#DELIVER_TLS_CONNECT_TIMEOUT 300
#DELIVER_COMMAND_LINE_TIMEOUT 300
#DELIVER_DATA_LINE_TIMEOUT 0
#DELIVER_DATA_SESSION_TIMEOUT 0

# Tarpit Times
#
# If a more specific tarpit time is not set, SMTP_TARPIT_DEFAULT will
# be used for that portion of a tarpitted connection.
#
#SMTP_TARPIT_DEFAULT 120
#SMTP_TARPIT_CONNECT 0
#SMTP_TARPIT_MAIL 0
#SMTP_TARPIT_RCPT 0
#SMTP_TARPIT_DATA 0
#SMTP_TARPIT_DATA_EOF 0

# DEBUG_LOGGING [n]
#
# Sets or increments the debug level.
#
#DEBUG_LOGGING 1

# SMTP_LISTEN_BACKLOG <max>
#
# Set the maximum socket backlog.
#
#SMTP_LISTEN_BACKLOG 64

# SYNC <ON|OFF>
#
# Enabling SYNC will provide stronger protection against data loss at
# the cost of some performance.
#
#SYNC ON

# DNS_AUTO_CONFIG <ON|OFF>
#
# Accept mail for any hostname that lists us as an MX.
#
#DNS_AUTO_CONFIG OFF

# Child process limits
#
#MAX_Q_RUNNERS_LAUNCH 10
#MAX_Q_RUNNERS_SLOW 250
#MAX_Q_RUNNERS_LOCAL 25
#MAX_Q_RUNNERS_RECEIVE 0

# Miscellaneous settings that are hopefully useful for JAIL
#
# MID_LIST <ON|OFF>
# SENDER_LIST <ON|OFF>
# JAIL_BOUNCE_ADDRESS <address>
# JAIL_BOUNCES <ON|OFF>
# JAIL_LOCAL <ON|OFF>

# Internal Tuning
#
# You probably don't need to change these.
#
#DISK_READ_INTERVAL 60
#COMMAND_READ_LIMIT 10
#DISK_READ_LIMIT 10
#EXPAND_INTERVAL 60
#JAIL_CLEANUP_INTERVAL 14400
