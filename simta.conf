#
# simta.conf template
#
core {
    # Base directory for simta queues and queue-like things.
    base_dir = /var/spool/simta;
    # File to store the main simta pid in.
    pid_file = /var/run/simta.pid;
    # Verbosity level, from 0 to 8
    debug_level = 1;
    # User to change to after startup
    user = simta;
    tls {
        ca_file = /etc/pki/tls/certs/ca-bundle.crt;
        # ca_directory = /path/to/dir;
    }
    # Domain to use for locally generated mail. Defaults to the system
    # hostname.
    #masquerade = mx.mail.example.com
    #
    # Override /etc/resolv.conf (mainly useful for testing)
    #dns {
    #   server = 127.0.0.1
    #   port = 10053
    #   timeout = 2s
    #}
    #
    # Enable statsd logging
    statsd {
        enabled = true;
        host = 127.0.0.1;
        port = 8125;
        prefix = simta;
    }

    poison {
        # Tag outbound messages with a poison pill header, and drop inbound
        # messages with a matching header.
        enabled = false;
        # Defaults to core.masquerade
        #slug = identifier.example.com
    }
}

receive {
    # NORMAL        Treat all incoming connections normally
    # DISABLED      Listen on configured ports, but refuse connections with a
    #               "554 No SMTP service here" banner. If a connection is
    #               active when this mode is switched to, disconnect.
    # GLOBAL_RELAY  Accept all mail regardless of security concerns
    #               Don't enable this unless you know what you're doing,
    #               because you become an open relay
    # TEMPFAIL      Tempfail all mail commands
    # TARPIT        Tempfail all mail transactions
    mode = normal;

    # Bad client behaviour will make simta switch to this mode. You probably
    # don't want to switch to global_relay...
    punishment = tempfail;

    # Listening ports
#   ports [ 25, 587 ]
    ipv4 = on;
    ipv6 = off;

    # There are several DNS list chains throughout the config, used for authz
    # at various points in the connection.
    #
    # Being found on a list will terminate processing of that DNSxL chain
    # unless it's a LOG_ONLY list. TRUST is the same as ACCEPT but exempts
    # the connection from checks like MAX_FAILED_RCPTS.
    #
    #{
    #   # <BLOCK|ACCEPT|TRUST|LOG_ONLY>
    #   action = block;
    #   list = mx-deny.dnsbl;
    #   message = denied by local policy;
    #   # non-IP chains can mangle the lookup text first. The term is always
    #   # lowercased, then:
    #   # domain-only: localpart@example.com -> example.com
    #   #domain_only = false;
    #   # algorithm: look up a hash instead of the raw string.
    #   #algorithm = sha1;
    #
    #   # Some DNS lists have multiple types of entries; you can override the
    #   # action for a specific return code:
    #   127.0.0.3 = log_only
    #   127.0.0.4 = accept
    #}

    connection {
        limits {
            # Maximum number of connections
            global = 2k;
            # Maximum number of new connections per throttle_interval
            throttle = 1k;
            throttle_interval = 1s;
            # Per-host limits
            per_host = 100;
            per_host_throttle = 100;
        }

        # Enable PROXY protocol
        proxy {
            enabled = false;
            timeout = 10s;
        }

        rdns {
            # <STRICT|RELAXED|CHILLAXED>
            # RELAXED allows connections with invalid rDNS, CHILLAXED also allows
            # connections with DNS errors during rDNS lookup.
            check = relaxed;
            message = denied by local policy;
        }

        libwrap {
            enabled = true;
            message = denied by local policy;
        }

        # DNSxLs to apply to all inbound connections
        # dns_lists []

        banner {
            delay = 0s;
            punish_writes = false;
        }
    }

    smtp {
        # <MSA|MTA|STRICT>
        # MSA mode will attempt to add missing headers to submitted messages.
        # STRICT will reject mail that fails RFC compliance checks.
        mode = mta;

        # In tempfail mode, commands will wait this long before returning
        # tempfail.
        tarpit = 0s;
    }

    tls {
        # Enables STARTTLS on normal ports and optionally listens on additional
        # TLS-wrapped ports.
        enabled = false;
        #certificate = /path/to/cert;
        #key = /path/to/key;
        ciphers = "EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:DH+CHACHA20:DH+AES128:DH+AES256:!MD5";
        #ports = [ 465 ]
        client_cert = false;
    }

    timeout {
        session = 1h;
        tls = 5min;
        inactivity = 10min;
        write = 5min;
        command = 5min;
        data = 1h;
        data_line = 5min;
    }

    srs {
        enabled = false;
        # <ALWAYS|FOREIGN|SMART>
        # FOREIGN rewrites addresses from other domains.
        # SMART rewrites addresses that would fail SPF on the next hop.
        rewrite = foreign;
        # Defaults to core.masquerade
        #domain = example.com
        #secret = theverysecretdiaries;
    }

    spf {
        enabled = true;
        strict = false;
    }

    dkim {
        enabled = true;
        # Only has an effect if deliver.dkim.enabled is true
        sign = true;
    }

    dmarc {
        enabled = true;
        strict = false;
        # Location of the Public Suffix List (available from
        # https://publicsuffix.org/). Without this, DMARC checks will not
        # attempt to determine the Organizational Domain and will return
        # inaccurate results for subdomains.
        #public_suffix_file = /path/to/psl;
    }

    arc {
        enabled = false;
        #domain = example.com;
        #selector = simta;
        #key = /path/to/key;
    }

    auth {
        authn {
            enabled = false;
            # Advertise fake authentication support and punish people who try to
            # use it.
            honeypot = false;
            # Override the SASL library's normal determination of the hostname.
            #domain = example.com;
        }
        authz {
            #dns_lists = [];
        }
        results {
            # Controls whether an RFC 7001 Authentication-Results header is
            # added to the message. If ARC is enabled, an ARC header set
            # (including ARC-Authentication-Results) will be added instead.
            enabled = true;
            # ADMD domain for the header; defaults to masquerade.
            #domain = example.com;
        }
    }

    mail_from {
        # Number of rejected MAIL commands before punishment begins. 0 is
        # unlimited.
        max_failures = 0;
        # Any DNS lists configured here will also be checked against the
        # RFC5322.From during the content filtering phase.
        #dns_lists []
    }

    rcpt_to {
        # These lists apply to the connecting IP, but require user opt-in
        # so they can't be checked until we know the recipient. This is
        # currently only supported for LDAP users.
        #dns_lists []
        # Number of rejected RCPT commands before punishment begins. 0 is
        # unlimited.
        max_failures = 0;
    }

    data {
        limits {
            # Maximum number of Received: headers; this will eventually
            # terminate trivial mail loops.
            received_headers = 80;
            # Maximum message size.
            message_size = 100mb;
        }

        checksum {
            enabled = true;
            # Which digest algorithms are available depends on your TLS
            # library's configuration.
            algorithm = sha1;
        }

        content_filter {
            enabled = false;
            #path = /path/to/filter
            # <ALWAYS|UNTRUSTED>
            when = untrusted;
            message = denied by local policy;
            # FIXME: this should be implemented
            #dns_lists []
        }
    }

    queue {
        # <FAST|SLOW|JAIL>
        # FAST  The Receive child will attempt delivery
        # SLOW  Messages will be sent to the slow queue without an initial
        #       delivery attempt.
        # JAIL  Incoming messages will be jailed.
        strategy = fast;
        # simta will wait to trigger a delivery attempt until it has accumulated
        # this number of messages (0 is unlimited)...
        aggression = 50;
        # ...or this amount of time has gone by with no new mail transactions.
        timer = 5s;
        # the number of concurrent deliver children a single receive process can
        # launch
        max_runners = 5;
    }
}

expand {
    # If enabled, simta will expand all messages in the unexpanded queue before
    # making a delivery attempt.
    aggressive = true;
}

deliver {
    limits {
        slow_runners = 250;
        local_runners = 25;
    }
    jail {
        #host = jail.mail.example.com;
        # alternate recipient for bounces of old jailed messages
        #parole_officer = acab@example.com
    }
    dkim {
        enabled = false;
        # Defaults to core.masquerade
        #domain = example.com;
        selector = simta;
        #key = /path/to/key
    }
    timeout {
        tls = 5min;
        command = 5min;
        data_session = 30min;
        data_line = 5min;
        fast_data_session = 5min;
        fast_data_line = 60s;
    }
    queue {
        # max age before messages bounce
        bounce = 3d;
        # messages larger than this will be truncated to just the headers in
        # the NDR.
        bounce_size = 524288;
    }
}

defaults {
    red {
        receive {
            user_not_found = User not found;
        }
        deliver {
            connection {
                # Keep reconnecting to MX entries that accepted at least one message.
                aggressive = true;
                # Maximum number of messages to attempt per connection
                max_messages = 10k;
                # Maximum number of recipients to attempt per message transaction.
                max_rcpts = 0;
            }

            queue {
                # <FIFO|SHUFFLE>
                strategy = fifo;
                wait {
                    # If a host is up, delivery attempts will occur approximately
                    # this far apart.
                    min = 5min;
                    # If a host is down, simta will back off attempt frequency, but
                    # will retry at least this often.
                    max = 80min;
                }
            }
            punt {
                enabled = false;
                always = false;
                # host = punt.mail.example.com;
            }
            local {
                enabled = false;
                agent = /usr/libexec/simta/simda $R /usr/bin/procmail -f $S;
            }
            bitbucket {
                enabled = false;
                delay = 0s;
            }
            secondary_mx = false;
            tls {
                enabled = true;
                required = false;
                verify = false;
                ciphers = "EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:!MD5";
            }
        }
    }

    red_rule {
        receive {
            enabled = true;
            required = false;
            sufficient = true;
        }
        expand {
            enabled = true;
            # Some expansion types will canonicalize email addresses
            # during expansion by stripping the first occurrence
            # of the separator(s) in the localpart and anything
            # after it. E.g. if this is set to '+' the address
            # 'junk+foo@example.com' will be treated as an alias of
            # 'junk@example.com'.
            subaddress_separators = "+";
        }
        alias {
            path = /etc/mail/aliases;
        }
        password {
            path = /etc/passwd;
        }
        ldap {
            timeout = 180;
            retries = 2;
            attributes {
                mail = mail;
                forwarding = mail;
                request = [ * ];
            }
            bind {
                method = simple;
            }
            objectclasses {
                person = [ umichPerson ];
                group = [ rfc822mailgroup ];
            }
            tls {
                enabled = false;
                required = false;
            }
        }
    }
}

# Default rules for localhost if there is no explicit config
domain "localhost.DEFAULT" {
        rule {
          type = alias;
        }
        rule {
          type = password;
        }
}

#domain "example.com" {
#   rule {
#       type = alias;
#       alias {
#           path = /etc/mail/aliases.example.com.db;
#       }
#       receive {
#           enabled = true;
#           required = false;
#           sufficient = true;
#       }
#       expand {
#           enabled = true;
#       }
#   }
#   rule {
#       type = accept;
#   }
#   rule {
#       type = password;
#       password {
#           path = /etc/passwd;
#       }
#   }
#   rule {
#       type = ldap;
#       associated_domain = umich.edu;
#       ldap {
#           uri = ldap://ldap.example.com/
#           debug = false;
#           tls {
#               enabled = false;
#               required = false;
#               ca = "";
#           }
#           bind {
#               dn = "cn=simta,ou=mail agents,ou=Security,dc=umich,dc=edu";
#               password = drowssap;
#               # <SIMPLE|SASL>
#               method = simple;
#           }
#           timeout = 3min;
#           objectclasses {
#               person = [ umichperson ];
#               group = [ rfc822mailgroup ];
#           }
#           search {
#               uri = "ldap:///ou=People,dc=umich,dc=edu?*?sub?uid=%25s";
#               rdnpref = false;
#               # <ALL|USER|GROUP>
#               type = user;
#           }
#           search {
#               uri = "ldap:///ou=People,dc=umich,dc=edu?*?sub?cn=%25s"
#               rdnpref = false;
#               type = user;
#           }
#           # List of attributes to retrieve; if not set, all attributes are
#           # requested.
#           attributes {
#               request = [];
#               mail = mail
#               forwarding = mailforwardingaddress;
#               group_forwarding = mailforwardingaddress;
#               vacation = onvacation;
#
#           vacation {
#               host = vacation.example.com;
#           }
#       }
#   }
#   rule {
#       type = srs;
#       srs {
#           secret = foo;
#       }
#   }
#   expand {
#       permit_subdomains = true;
#   }
#   deliver {
#       secondary_mx = true;
#       local_delivery = false;
#       lda = /usr/bin/procmail -f $S;
#       tls {
#           enabled = true;
#           required = false;
#           verify = false;
#           #ciphers = MD5;
#       }
#       bitbucket {
#           when = never;
#           delay = 0s;
#       }
#   }
#
#}
